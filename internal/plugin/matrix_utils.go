// Copyright 2024 The vault-plugin-secrets-vector-dpe Authors
// SPDX-License-Identifier: Apache-2.0

package plugin

import (
	"crypto/rand"
	"fmt"
	"log"
	"math"
	mathrand "math/rand/v2"

	"gonum.org/v1/gonum/mat"
)

// MaxDimension is the maximum allowed vector dimension.
// This limit prevents DoS attacks via excessive memory allocation.
// A 8192x8192 float64 matrix requires ~512MB of RAM.
const MaxDimension = 8192

// GenerateOrthogonalMatrix generates a random orthogonal matrix using QR decomposition.
//
// The matrix is generated by:
// 1. Creating a random Gaussian matrix (each element ~ N(0,1))
// 2. Applying QR decomposition to extract the Q factor
//
// This produces a matrix uniformly distributed according to the Haar measure
// on the orthogonal group O(n), which is the mathematically correct way to
// sample a "random rotation" in high-dimensional space.
//
// The seed must be exactly 32 bytes (256 bits) and is used to initialize
// a ChaCha8 CSPRNG for deterministic but cryptographically secure generation.
func GenerateOrthogonalMatrix(seed []byte, dim int) (*mat.Dense, error) {
	if dim <= 0 {
		return nil, fmt.Errorf("dimension must be positive")
	}
	if dim > MaxDimension {
		return nil, fmt.Errorf("dimension %d exceeds maximum allowed %d", dim, MaxDimension)
	}
	if len(seed) != 32 {
		return nil, fmt.Errorf("seed must be exactly 32 bytes (got %d)", len(seed))
	}

	// Warn if dimension is large (matrix generation can be slow).
	if dim > 2048 {
		log.Printf("[WARN] vault-dpe: generating %dx%d orthogonal matrix – this can be slow", dim, dim)
	}

	// Use ChaCha8 for high-performance CSPRNG seeded from the key.
	var seed32 [32]byte
	copy(seed32[:], seed)
	rng := mathrand.New(mathrand.NewChaCha8(seed32))

	// Generate random Gaussian matrix.
	data := make([]float64, dim*dim)
	for i := range data {
		data[i] = rng.NormFloat64()
	}
	randomMatrix := mat.NewDense(dim, dim, data)

	// QR decomposition to extract orthogonal matrix Q.
	var qr mat.QR
	qr.Factorize(randomMatrix)

	var q mat.Dense
	qr.QTo(&q)

	// Validate orthogonality before returning.
	if err := ValidateOrthogonality(&q); err != nil {
		return nil, fmt.Errorf("generated matrix failed orthogonality check: %w", err)
	}

	return &q, nil
}

// ValidateOrthogonality verifies that Q^T * Q ≈ I (identity matrix).
// This is a mathematical property of orthogonal matrices.
// Tolerance is 1e-6 to account for floating-point precision.
func ValidateOrthogonality(q *mat.Dense) error {
	r, c := q.Dims()
	if r != c {
		return fmt.Errorf("matrix is not square: %dx%d", r, c)
	}

	// Compute product = Q^T * Q (should be identity).
	var product mat.Dense
	product.Mul(q.T(), q)

	// Check each element against expected identity matrix.
	const epsilon = 1e-6
	for i := 0; i < r; i++ {
		for j := 0; j < c; j++ {
			val := product.At(i, j)
			expected := 0.0
			if i == j {
				expected = 1.0
			}
			if math.Abs(val-expected) > epsilon {
				return fmt.Errorf("orthogonality check failed at (%d, %d): got %v, expected %v",
					i, j, val, expected)
			}
		}
	}
	return nil
}

// NewSecureRNG creates a new CSPRNG seeded with 32 bytes of entropy from crypto/rand.
// It uses the ChaCha8 algorithm from math/rand/v2 for high performance.
func NewSecureRNG() (*mathrand.Rand, error) {
	var seed [32]byte
	if _, err := rand.Read(seed[:]); err != nil {
		return nil, fmt.Errorf("failed to generate random seed: %w", err)
	}
	return mathrand.New(mathrand.NewChaCha8(seed)), nil
}

// GenerateSecureNoise generates the perturbation vector λ for the SAP scheme.
// It uses a ChaCha8 CSPRNG seeded with fresh entropy from crypto/rand.
//
// The buffer parameter allows reuse of allocated memory; if nil or too small,
// a new slice will be allocated.
func GenerateSecureNoise(buffer []float64, dim int, scalingFactor, approximationFactor float64) ([]float64, error) {
	rng, err := NewSecureRNG()
	if err != nil {
		return nil, err
	}
	return GenerateNormalizedVector(rng, buffer, dim, scalingFactor, approximationFactor)
}

// GenerateNormalizedVector generates the perturbation vector λ for the SAP scheme.
//
// The algorithm mirrors IronCore Alloy's implementation (crypto.rs):
//  1. u ← N(0, I_d)         Sample from multivariate normal
//  2. x' ← U(0, 1)          Sample uniform random
//  3. x ← (s·β/4) · (x')^(1/d)  Compute radius for uniform ball sampling
//  4. λ ← u · x / ||u||     Normalize and scale
//
// This produces a vector uniformly distributed within a ball of radius (s·β)/4,
// which provides the probabilistic noise component of the SAP scheme.
func GenerateNormalizedVector(rng *mathrand.Rand, buffer []float64, dim int, scalingFactor, approximationFactor float64) ([]float64, error) {
	// Use provided buffer or allocate.
	lambdaM := buffer
	if cap(lambdaM) < dim {
		lambdaM = make([]float64, dim)
	} else {
		lambdaM = lambdaM[:dim]
	}

	// Step 1: Sample u from N(0, I_d).
	// Since covariance is identity, sample d independent standard normals.
	var normSq float64
	for i := 0; i < dim; i++ {
		val := rng.NormFloat64()
		lambdaM[i] = val
		normSq += val * val
	}
	uNorm := math.Sqrt(normSq)

	// Guard against division by zero (astronomically unlikely).
	if uNorm == 0 {
		return nil, fmt.Errorf("generated normal vector has zero norm")
	}

	// Step 2: Sample x' from U(0, 1).
	xPrime := rng.Float64()

	// Step 3: Compute radius for uniform ball sampling.
	// R = (s · β) / 4
	// x = R · (x')^(1/d)
	radius := (scalingFactor * approximationFactor) / 4.0
	x := radius * math.Pow(xPrime, 1.0/float64(dim))

	// Step 4: Normalize and scale: λ = u · x / ||u||.
	scale := x / uNorm
	for i := 0; i < dim; i++ {
		lambdaM[i] *= scale
	}

	return lambdaM, nil
}

